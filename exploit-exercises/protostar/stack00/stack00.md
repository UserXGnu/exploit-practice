
# Stack Overflow Level 0

Well, as you may expect, this is a simple post of [exploit-exercise]/[protostar] 
stack overflow level 00 writeup. I hope you enjoy!


## The code

```C
/**
 * From: (https://exploit-exercises.com/protostar/stack0/)
 * Compile: gcc stack01.c -o stack01 -fno-stack-protector -z execstack
 */
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  modified = 0;
  gets(buffer);

  if(modified != 0) {
      printf("you have changed the 'modified' variable\n");
  } else {
      printf("Try again?\n");
  }
}

```

## The problem

Well, as you can see, we have two variables, a buffer of 64 bytes and an interger of 4 bytes, the interger starts with __0__
and further down in the code it's used to test if it's different from __0__, if that's the case, we achieved our goal, but if
otherwise, we need to __try harder__.

## Step-by-step solution

To come out with some sort of solution, we need to first understand the layout of these variables at the stack so that we can
fully understand what we can or cannot do. So let's get right into it:

### Debuging

After compiling the code, open up gdb, set a break-point at the beginning of main function and run it, like this:

``` bash
$ gdb stack00
pwndbg> b main
pwndbg> run
```
The output should look like:

![Variales Offsets](https://raw.githubusercontent.com/UserXGnu/exploit-practice/master/exploit-exercises/protostar/stack00/variables_offset.png)

These two arrows, added by me to the screenshot, spots the location of the known variables.<br>
Alright so, we have buffer at 80 bytes under the __frame pointer__ and we have our _interger modified_  variable at 
4 bytes under the __frame pointer__, what does that mean? 

That means that the distance between the beginning of the buffer and the interger variable is of 76 bytes, which means, 
once that we know that get() function is vulnerable, once it's called to fill in the buffer we could send 76 bytes plus 4 bytes
which would overwrite the interger. Let's test it?

alright then, try this:

``` bash
$ ruby -e 'print "A"*76 + "B"*4' | ./stack00
```
You should get an output that looks like this:

![gotcha!](https://raw.githubusercontent.com/UserXGnu/exploit-practice/master/exploit-exercises/protostar/stack00/solution.png)
